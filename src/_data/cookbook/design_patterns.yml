- title: "Persistent storage architecture: Key-value data"
  tags:
    - data
    - shared-preferences
    - dark mode
  description: Save application data to a user's on-device key-value store.
  path: /cookbook/architecture/key-value-data
  img: /assets/images/docs/app-architecture/design-patterns/kv-store-icon.svg
  body: |
    Most Flutter applications, no matter how small or big they are, 
    require storing data on the user’s device at some point, 
    such as API keys, user preferences or data that should be available offline.
    
    In this recipe, you will learn how to integrate persistent storage for key-value
    data in a Flutter application by implementing a switchable light-mode and dark-mode theme 
    in an application and storing the users preference.
- title: "Persistent storage architecture: SQL"
  tags:
    - data
    - SQL
  description: Save complex application data to a user's device with SQL.
  path: /cookbook/architecture/sql
  img: /assets/images/docs/app-architecture/design-patterns/sql-icon.svg
  body: |
    Most Flutter applications, no matter how small or big they are, 
    might require storing data on the user’s device at some point. 
    For example, API keys, user preferences or data that should be available offline.

    In this recipe, you will learn how to integrate persistent storage 
    for complex data using SQL by implementing a todo-list app that 
    follows our recommended Flutter app architecture.
- title: Offline-first support
  description: Implement offline-first support for one feature in an application.
  tags:
    - data
    - user experience
    - repository pattern
  path: /cookbook/architecture/offline-first
  img: /assets/images/docs/app-architecture/design-patterns/offline-first-icon.svg
  body: |
    An offline-first application is an app capable of offering most or all of its 
    functionality while being disconnected from the internet. 
    Offline-first applications usually rely on stored data to offer users temporary access 
    to data that would otherwise only be available online.

    Some offline-first applications combine local and remote data seamlessly, while other applications 
    inform the user when the application is using cached data. In the same way, 
    some applications synchronize data in the background while others require the 
    user to explicitly synchronize it. It all depends on the application requirements and 
    the functionality it offers, and it’s up to the developer to decide which implementation fits their needs.

    In this guide, you will learn how to implement different approaches to offline-first 
    in Flutter applications that follow our recommended architecture guidelines.
- title: Optimistic state
  description: Improve the perception of responsiveness of an application by implementing optimistic state.
  tags:
    - user experience
    - asynchronous dart
  path: /cookbook/architecture/optimistic-state
  img: /assets/images/docs/app-architecture/design-patterns/optimistic-state-icon.svg
  body: |
    When building user experiences, the perception of performance is sometimes just as 
    important as the actual performance of the code. In general, users don’t like 
    waiting for an action to finish to see the result, and anything that takes more 
    than a few milliseconds could be considered “slow” or “unresponsive” from the user’s perspective.

    Developers can help mitigate this negative perception by presenting a successful UI 
    state before the background task is fully completed. An example of this would be 
    tapping a “Subscribe” button, and seeing it change to “Subscribed” instantly, even if the 
    background call to the subscription API is still running.
    
    This technique is known as Optimistic State, Optimistic UI or Optimistic User Experience. 
    In this recipe, you will implement optimistic state for a feature in an application that follows our
    recommended architecture guidelines.
- title: The command pattern
  description: Simplify view model logic by implementing a Command class.
  tags:
    - mvvm
    - asynchronous dart
    - state
  path: /cookbook/architecture/command
  img: /assets/images/docs/app-architecture/design-patterns/command-icon.svg
  body: |
    A command is a class that wraps a method and helps to handle the different 
    states of that method, such as running, complete, and error.

    View models can use commands to handle interaction and run actions.
    They can also be used to display different UI states,
    like loading indicators when an action is running,
    or an error dialog when an action failed.

    View models can become very complex as an application grows 
    and features become bigger. 
    Commands can help to simplify view models and reuse code.

    In this guide, you will learn how to use the command pattern 
    to improve your view models.
- title:  Better error handling
  description: Improve error handling across classes with Result objects.
  tags:
    - error handling
    - services
  path: /cookbook/architecture/result
  img: /assets/images/docs/app-architecture/design-patterns/result-icon.svg
  body: |
    Dart provides a built-in error handling mechanism 
    with the ability to throw and catch exceptions.
    
    Dart’s exceptions are unhandled exceptions.
    This means that methods that throw exceptions don’t need to declare them,
    and calling methods aren't required to catch them either.
    
    This can lead to situations where exceptions are not handled properly.
    In large projects, developers might forget to catch exceptions,
    and the different application layers and components
    could throw exceptions that aren’t documented. 
    This can lead to errors and crashes.
    
    In this guide, you will learn about this limitation
    and how to mitigate it using the result pattern.

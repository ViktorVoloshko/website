- title: "Persistent storage architecture: Key-value data"
  tags:
    - data
    - shared-preferences
    - dark mode
  description: Save application data to a user's on-device key-value store.
  path: /cookbook/architecture/key-value-data
  img: /assets/images/docs/app-architecture/design-patterns/kv-store-icon.svg
  body: |
    Most Flutter applications, no matter how small or big they are, 
    require storing data on the user’s device at some point, 
    such as API keys, user preferences or data that should be available offline.
    
    In this recipe, you will learn how to integrate persistent storage for key-value
    data in a Flutter application by implementing a switchable light-mode and dark-mode theme 
    in an application and storing the users preference.
- title: "Persistent storage architecture: SQL"
  tags:
    - data
    - SQL
  description: Save complex application data to a user's device with SQL.
  path: /cookbook/architecture/sql
  img: /assets/images/docs/app-architecture/design-patterns/sql-icon.svg
  body: |
    Most Flutter applications, no matter how small or big they are, 
    might require storing data on the user’s device at some point. 
    For example, API keys, user preferences or data that should be available offline.

    In this recipe, you will learn how to integrate persistent storage 
    for complex data using SQL by implementing a todo-list app that 
    follows our recommended Flutter app architecture.
- title: "Offline-first support"
  description: Implement offline-first support for one feature in an application.
  tags:
    - data
    - user experience
    - repository pattern
  path: /cookbook/architecture/offline-first
  img: /assets/images/docs/app-architecture/design-patterns/offline-first-icon.svg
  body: |
    An offline-first application is an app capable of offering most or all of its 
    functionality while being disconnected from the internet. 
    Offline-first applications usually rely on stored data to offer users temporary access 
    to data that would otherwise only be available online.

    Some offline-first applications combine local and remote data seamlessly, while other applications 
    inform the user when the application is using cached data. In the same way, 
    some applications synchronize data in the background while others require the 
    user to explicitly synchronize it. It all depends on the application requirements and 
    the functionality it offers, and it’s up to the developer to decide which implementation fits their needs.

    In this guide, you will learn how to implement different approaches to offline-first 
    in Flutter applications that follow our recommended architecture guidelines.
- title: Optimistic State
  description: Improve the perception of responsiveness of an application by implementing optimistic state.
  tags:
    - user experience
    - asynchronous dart
  path: /cookbook/architecture/optimistic-state
  img: /assets/images/docs/app-architecture/design-patterns/optimistic-state-icon.svg
  body: |
    When building user experiences, the perception of performance is sometimes just as 
    important as the actual performance of the code. In general, users don’t like 
    waiting for an action to finish to see the result, and anything that takes more 
    than a few milliseconds could be considered “slow” or “unresponsive” from the user’s perspective.

    Developers can help mitigate this negative perception by presenting a successful UI 
    state before the background task is fully completed. An example of this would be 
    tapping a “Subscribe” button, and seeing it change to “Subscribed” instantly, even if the 
    background call to the subscription API is still running.
    
    This technique is known as Optimistic State, Optimistic UI or Optimistic User Experience. 
    In this recipe, you will implement optimistic state for a feature in an application that follows our
    recommended architecture guidelines.
